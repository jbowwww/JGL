using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using JGL.Geometry;
using JGL.Debugging;

namespace JGL.Heirarchy
{
	/// <summary>
	/// An <see cref="JGL.Heirarchy.Entity"/> which represents a tangible object in a <see cref="JGL.Heirarchy.Scene"/>,
	/// usually contained within a <see cref="JGL.Heirarchy.Sector"/>
	/// </summary>
	[Serializable]
	public class MeshObject : Object
	{
		#region IGeometry implementation (mesh data shared across 1 or more Mesh instances that are subentities of this entity)
		/// <summary>
		/// The vertices.
		/// </summary>
		public IList<Vertex> Vertices { get; protected set; }
		
		/// <summary>
		/// The normals.
		/// </summary>
		public IList<Normal> Normals { get; protected set; }
		
		/// <summary>
		/// The tex coords.
		/// </summary>
		public IList<TexCoord> TexCoords { get; protected set; }
		
		/// <summary>
		/// The texture.
		/// </summary>
		public MaterialLibrary Materials { get; protected set; }
		#endregion
		
		#region Constructors
		/// <summary>
		/// Initializes a new instance of the <see cref="JGL.Heirarchy.MeshObject"/> class.
		/// </summary>
		/// <param name="children">Child <see cref="JGL.Heirarchy.Entity"/>s.</param>
		public MeshObject (params Entity[] children)
			: base (children)
		{
			
		}
		
		/// <summary>
		/// Initializes a new instance of the <see cref="JGL.Heirarchy.MeshObject"/> class.
		/// </summary>
		/// <param name="name">Entity name</param>
		/// <param name="children">Child <see cref="JGL.Heirarchy.Entity"/>s.</param>
		public MeshObject (string name, params Entity[] children)
			: base (name, children)
		{
			
		}
		
		/// <summary>
		/// Initializes a new instance of the <see cref="JGL.Heirarchy.MeshObject"/> class by loading it from a lightwave
		/// .OBJ file. The entity's name is the filename without the extension
		/// </summary>
		/// <param name="filename">File name (and optionally path) of the lightwave .OBJ file to load</param>
		/// <param name="dummy">Dummy parameter to differentiate this constructor overload from the one above</param>
		/// <param name="children">Child <see cref="JGL.Heirarchy.Entity"/>s.</param>
		public MeshObject (string filename, bool dummy, params Entity[] children)
			: base(null, children)
		{
			using (Stream s = File.Open(filename, FileMode.Open))
				LoadObjFile(s);
		}
		#endregion
		
		/// <summary>
		/// Clears the geometry data.
		/// </summary>
		protected void Clear()
		{
			Vertices = new List<Vertex>();
			Normals = new List<Normal>();
			TexCoords = new List<TexCoord>();
		}
		
		/// <summary>
		/// Loads the object file.
		/// </summary>
		/// <param name="fs">Stream containing lightwave .OBJ format data</param>
		public void LoadObjFile(Stream fs)
		{
			ClearGeometryData();
			using (StreamReader sr = new StreamReader(fs))
			{
				string line;
				string[] tokens;
				Mesh mesh = null;
				while (!sr.EndOfStream)		//(fs.Position < (fs.Length - 1))
				{
					line = sr.ReadLine();
					tokens = line.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
					if (tokens.Length > 0)
					{
						switch (tokens[0].ToLower())
						{
							case "mtllib":
								Debug.Assert(tokens.Length == 2);
								Materials = new MaterialLibrary(tokens[1]);
								break;
							case "v":
								Debug.Assert(tokens.Length == 4);
								Vertices.Add(new Vertex(double.Parse(tokens[1]), double.Parse(tokens[2]), double.Parse(tokens[3])));
								break;
							case "vn":
								Debug.Assert(tokens.Length == 4);
								Normals.Add(new Normal(double.Parse(tokens[1]), double.Parse(tokens[2]), double.Parse(tokens[3])));
								break;
							case "vt":
								Debug.Assert(tokens.Length == 3);
								TexCoords.Add(new TexCoord(double.Parse(tokens[1]), double.Parse(tokens[2])));
								break;
							case "g":
								mesh = new Mesh(tokens.Length > 1 ? tokens[1] : null, this);
								Add(mesh);
								break;
							case "usemtl":
								Debug.Assert(tokens.Length == 2 && mesh != null && Materials != null);
								mesh.Material = Materials[tokens[1]];
								break;
							case "f":
								Debug.Assert(tokens.Length == 4 && mesh != null);
								Debug.Assert(tokens[1].Split(new char[] {'/'}, StringSplitOptions.RemoveEmptyEntries).Length == 3);
								int[] v = new int[3];
								int[] n = new int[3];
								int[] t = new int[3];
								for (int i = 1; i < 4; i++)
								{
									string[] tvparts = tokens[i].Split(new char[] {'/'}, StringSplitOptions.RemoveEmptyEntries);
									v[i - 1] = int.Parse(tvparts[0]) - 1;
									n[i - 1] = int.Parse(tvparts[1]) - 1;
									t[i - 1] = int.Parse(tvparts[2]) - 1;
								}
								mesh.Triangles.Add(new Triangle(v, n, t));
								break;
						}
					}
				}				
			}
		}

		/// <summary>
		/// Gets child meshes
		/// </summary>
		public IEnumerable<Mesh> Meshes {
			get { return Entities.OfType<Mesh>(); }
		}
	}
}

